# ポーカーの役（ハンド）判定の方法

## ハンドの種類

https://ja.wikipedia.org/wiki/%E3%83%9D%E3%83%BC%E3%82%AB%E3%83%BC%E3%83%BB%E3%83%8F%E3%83%B3%E3%83%89%E3%81%AE%E4%B8%80%E8%A6%A7

より、

- ストレートフラッシュ
- フォーカード
- フルハウス
- フラッシュ
- ストレート
- スリーカード
- ツーペア
- ワンペア
- ブタ（high cards)

### 各ハンドを数理的に定義する

この定義が自力でできるかどうかでポーカーのハンド判定が楽にできるかが決まる。
ここでは、ハートやスペード等のことを「スート」、A,2~10,J,Q,Kのことを「ランク」と呼ぶ。

#### ペア

同じランクのカードが2枚以上ある状態のこと。
ペアの数`pairs`は、 `0 <= pairs <= 2 ` の範囲を取る。

#### カインド

同じランクのカードが手札に何枚あるかを表す。
カインドの数 `kinds` は、 `1 <= kinds <= 4` の範囲を取る。
なお、ペアが存在する場合は必然的に`kinds`は2以上になる。

#### ストレート状態

5枚のカードのランクが順列になっている状態であること。
A=1, J=11, Q=12, K=13 とみなす。
また、 10,J,Q,K,Aの組み合わせもストレート状態である。

#### フラッシュ状態

5枚のカードのスートが全て同じ状態。

### ハンド判定

以上の4つの状態の組み合わせで全てのハンドが表現できる。表にするとこのようになる。

|ハンド名|ペア|カインド|ストレート|フラッシュ|
|----|----|----|----|----|
|ストレートフラッシュ|-|-|Yes|Yes|
|フォーカード|-|4|-|-|-|
|フルハウス|1以上|3|-|-|
|フラッシュ|-|-|-|Yes|
|ストレート|-|-|Yes|-|
|スリーカード|-|3|-|-|
|ツーペア|2|-|-|-|
|ワンペア|1|-|-|-|
|ブタ|0|0|No|No|

※表中の"-"は「判定する必要がない」ことを表す。

## 各状態を判定、計算するアルゴリズムの例

ここではできる限り入門者向けの平素な方法（基本的な条件分岐と繰り返し）で判定方法の例を記載します。効率、エフェクティブな考え方ではありませんのでご了承ください。そもそもこの資料そのものが初心者向けです。

## 下準備

ランクは数値に変換しておきます。
ランクだけが入った配列と、スートだけが入った配列をそれぞれ作成します。

### ペアの数

ペアの数の数え方は、ランクをソートし、先頭から配列を走査し、隣り合うランクが同じかどうかを調べて、同じだったらペアの数に1ずつ加算していくようにします。

まずはカードの組からランクだけを取り出し、昇順でソートします。

ペアの数を表す変数`pairs`は最初0で初期化しておきます。
現在チェック中のランクでペアが発見されたかどうかのフラグを表す変数`found`を`false`で初期化しておきます。

次に先頭のランクを変数`currentRank`に代入し、残りの4つのランクを順番にチェックしていきます。チェック対象のランクを`rank`とすると、

- `rank` != `currentRank`の場合、以下の処理を行います。
  - `currentRank`に `rank`を代入
  - `found`をfalseにセット
- そうでない場合、さらに`found`をチェックし、以下の処理を行います。
  - `found` == true の場合、何もしない
  - `found` == false の場合、`pairs`に1加算し、`found`をtrueにする

`found`の用途は、同じランクが3回以上出現した場合でもペア数を1と数えるためです。

### カインドの数

カインド数の数え方は、ランク配列をソートし、先頭から配列を走査し、隣り合うランクが同じかどうかを調べて「同じランクのカードの枚数」の最大値を記録します。

まずはカードの組からランクだけを取り出し、昇順でソートします。

カインドの数を表す変数`kinds`は最初0で初期化しておきます。
現在チェック中のランクのカインド数を表す変数`currentKind`を0で初期化しておきます。
現在チェック中のランクを表す変数`currentRank`を0で初期化しておきます。

ランク配列の先頭から配列を走査します。以下の条件に従ってチェックしていきます。

- `rank` != `currentRank`の場合、以下の処理を行います。
  - `kind`より`currentKind`が大きい場合、`kind`に`currentKind`を代入
  - `currentRank`に `rank`を代入
  - `currentKind`に1を代入
- そうでない場合、`currentKind`に1加算する

最後に、"`kind`より`currentKind`が大きい場合、`kind`に`currentKind`を代入"をもう一度行います。

ペアとカインドの計算はやり方が非常に似通っているため、同時に行うことも可能です。

### フラッシュ状態の判定

これは非常に単純で、スート配列の中身が全て同じであればフラッシュ状態です。

### ストレート状態の判定

この判定は少々複雑です。

まず、ランクの配列を複製した新しい配列を用意します。これは、ランク配列を壊すような処理を今から行うため、元の配列に影響させないようにするためです。以降は複製したランク配列に対して処理を行います。

次に、ランク配列の中に数値1のカードが入っていた場合、`14`の数値を配列に追加します。この場合、要素数が6の配列となります。

ランク配列をソートします。

数値が連続している個数を記録する変数`straighting`を0で初期化しておきます。

配列の先頭から操作し、i番目の要素とi+1番目の要素の数値差が1であれば`straighting`に1加算します。そうでなければ`straighting`に0を代入します。
`straighting`が4になった時点でループを抜けます。

`straighting`が4の場合、ストレート状態となります。

### 14を加える理由

K -> A の連続性をチェックするためです。

カードのランクが 10 J Q K A の場合、数値が連続している状態であるためには、Aが14と同じ扱いになれば良いことがわかります。
この場合、元の数値"1"は何も意味をなさないですが、上記の判定方法であれば [1,10,11,12,13,14]という配列でチェックされ、
- 1と10をチェックし、数値差が1でないので`straighting`は0になる
- 10と11をチェックし、数値差が1なので`straighting`は1になる
- 11と12をチェックし、数値差が1なので`straighting`は2になる
- 12と13をチェックし、数値差が1なので`straighting`は3になる
- 13と14をチェックし、数値差が1なので`straighting`は4になる

という処理になり、めでたく`straighting`は4でストレート状態と判定されます。

逆に[A 2 3 4 5]というカードの組み合わせである場合、14を配列に加えても最初の5つの数値で`straighting`は4になるので14のチェックを待たずにストレート状態と判定できます。

## ハンドの判定

上記の判定表をもとに、上から順番に条件を満たすかどうかを判定すればOKです。

